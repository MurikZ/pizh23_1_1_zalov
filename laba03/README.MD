#  Лабораторная работа №3  
## Тема: Рекурсия и мемоизация  
**Дисциплина:** Алгоритмы и структуры данных  
**Студент:** *Залов Мурат*  
**Группа:** *ПИЖ-б-о-23-1*  

---

##  Цель работы
1. Освоить принципы построения рекурсивных алгоритмов.  
2. Научиться использовать мемоизацию для оптимизации рекурсивных функций.  
3. Реализовать практические задачи с применением рекурсии.  
4. Провести экспериментальное сравнение эффективности рекурсивных и мемоизированных реализаций.  


##  Реализованные алгоритмы

### Файл **`recursion.py`**
| Функция | Назначение | Сложность | Глубина |
|----------|-------------|------------|----------|
| `factorial(n)` | Факториал числа n | O(n) | n |
| `fib(n)` | n-е число Фибоначчи (наивно) | O(φ^n) | n |
| `pow_fast(a, n)` | Быстрое возведение в степень | O(log n) | O(log n) |

---

### Файл **`memoization.py`**
| Функция | Назначение | Сложность |
|----------|-------------|------------|
| `fib_naive_count(n)` | Наивная рекурсивная Фибоначчи с подсчётом вызовов | O(φ^n) |
| `fib_memoized(n)` | Мемоизированная версия (через `functools.lru_cache`) | O(n) |

---

### Файл **`recursion_tasks.py`**
| Задача | Описание | Сложность |
|--------|-----------|------------|
| `binary_search_recursive()` | Рекурсивный бинарный поиск | O(log n) |
| `walk_fs_recursive()` | Рекурсивный обход файловой системы | O(N), где N — число файлов/каталогов |
| `hanoi()` | Решение задачи Ханойских башен | O(2^n) |

---

## Экспериментальная часть

Проведено сравнение времени выполнения наивного и мемоизированного вычисления чисел Фибоначчи при `n = 35`.

| Реализация | Результат | Кол-во вызовов | Время (сек) |
|-------------|------------|----------------|--------------|
| Наивная рекурсия | 9 227 465 | 29 860 703 | **2.7726** |
| Мемоизация (`lru_cache`) | 9 227 465 | 69 (0..35) | **0.000051** |

---

## График времени выполнения

На графике показано сравнение скорости вычисления чисел Фибоначчи от `n=5` до `n=35`.


![img.png](img.png)

> Видно, что время работы наивной версии растёт экспоненциально,  
> а мемоизированная версия — почти линейно (каждое значение вычисляется один раз).

---

##  Рекурсивный обход файловой системы

Для теста создана искусственная структура с глубиной **120** вложенных каталогов.  
Рекурсивный обход успешно достиг глубины **120**, что подтвердило корректность функции `walk_fs_recursive()`.

---

##  Задача «Ханойские башни»

Пример решения для 3 дисков:

| № | Диск | Из | В |
|---|------|----|---|
| 1 | 1 | A | C |
| 2 | 2 | A | B |
| 3 | 1 | C | B |
| 4 | 3 | A | C |
| 5 | 1 | B | A |
| 6 | 2 | B | C |
| 7 | 1 | A | C |

---

## Анализ результатов

1. **Экспоненциальный рост времени** для наивной Фибоначчи объясняется тем, что функция вычисляет одни и те же значения многократно. Например, `fib(35)` вызывает `fib(34)` и `fib(33)`, каждая из которых снова вызывает предыдущие — происходит **повторение подзадач**.

2. **Мемоизация** устраняет избыточные вычисления — каждое значение `fib(k)` вычисляется **один раз** и сохраняется. Благодаря этому временная сложность снижается с `O(φ^n)` до `O(n)`.

3. **Проблема глубокой рекурсии** связана с ограниченным стеком вызовов: при глубине > 1000 Python выдаёт `RecursionError`. В наших тестах глубина 120 безопасна.

4. **Задача Ханойских башен** демонстрирует идеальную структуру рекурсивного решения — для `n` дисков требуется `2^n - 1` перемещений. Для 3 дисков — 7 шагов.

5. **Вывод:** мемоизация и грамотное определение базового случая делают рекурсивные алгоритмы эффективными и безопасными.

---

## Контрольные вопросы и ответы

| № | Вопрос | Краткий ответ |
|---|---------|----------------|
| 1 | Что такое базовый случай и рекурсивный шаг? | Базовый случай — условие выхода; рекурсивный шаг — вызов функции с приближением к базовому случаю. Без базового случая — бесконечная рекурсия. |
| 2 | Как работает мемоизация? | Сохраняет результаты вызовов, избегая повторных вычислений. Для Фибоначчи снижает сложность с O(φ^n) до O(n). |
| 3 | Почему глубокая рекурсия опасна? | Каждый вызов хранится в стеке; при переполнении возникает RecursionError. |
| 4 | Как решается задача Ханойских башен? | Рекурсивно: перенести n−1 дисков, переместить последний, затем снова n−1 дисков. |
| 5 | Рекурсия vs итерация — плюсы и минусы? | Рекурсия проще и нагляднее, но может быть медленнее и ограничена глубиной стека. Итерация — быстрее и безопаснее, но код сложнее. |

---

## Выводы

- Рекурсия — мощный инструмент для выражения повторяющихся и иерархических задач.  
- Мемоизация радикально улучшает производительность за счёт устранения повторных вычислений.  
- Важно правильно определять **базовый случай**, чтобы избежать переполнения стека.  
- Эксперименты подтвердили: прирост производительности при мемоизации — **в десятки тысяч раз**.

---
